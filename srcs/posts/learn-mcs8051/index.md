---
title: 单片机习题整理
createdDate: 2020-11-03 20:19:36
layout: post
zone: Asia/Shanghai
tags:
- 单片机
- 学习资料
categories:
- 单片机
comment: true
---

赶在期中考试前把单片机的课后习题整理出来...

(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧...)

<!--more-->

------

<div class="alert-blue">
本篇内容为作者整理资料所得, 仅供学习使用。如需转载请务必遵守<a style="color:#666" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">CC BY-NC-ND 4.0</a>协议。<br/>
请勿将本篇内容当作权威的教学辅导资料来使用, 因无法保证100%准确, 仅供参考。<br/>
如果发现了本篇存在的错误, 欢迎在页面下方提issue指正。<br/>
</div>

1. 8051复位后从地址`0000H`开始执行程序, SP的值为`07H`。

   PC: 两字节(16位)寄存器, 也称程序计数器。
  
   SP: 堆栈指针, 指示出堆栈顶部在**内部RAM块**中的位置。
   
   单片机的堆栈设在了内部RAM区, 单片机复位后, SP中的内容为`07H`(指向第0组工作寄存器的R7), 堆栈实际上从08H开始。

   若SP被初始化为`39H`, 则堆栈实际上是从`3AH`开始的。
  
   执行`RET`指令后, SP值减2 (因为PC为2字节寄存器), 将调用指令的下一条指令的首地址送入PC中。

2. PSW中的RS1 RS0=`10B`时, R2的RAM地址为`12H`。
   
   PSW： 程序状态字寄存器, 从`PSW.7`至`PSW.0`分别为`Cy`(进位标志位), `Ac`(辅助进位标志位), `F0`(标志位), `RS1`和`RS0`(寄存器区选择控制位), `OV`(溢出位), 保留位, `P`(奇偶标志位, 奇数为1, 偶数为0)。
   
   RS1 RS0 = `10B`时, 使用第二组工作寄存器区, 第0组工作寄存器区R0-R7的地址为`00H-07H`, 第1组为`08H-0FH`, 第2组为`10H-17H`, 第3组为`18H-1FH`(每组长度为8个字节, 每个寄存器占1个字节)。
  
  因此, 当A为`01110010B`时, PSW中P为0(偶数个1)。
  
  假设PSW为18H, 即`00011000B`, 此时使用第3组工作寄存器, R0地址为18H, R7地址为1FH。

  复位后, 默认选择的寄存器区是0区。

3. 8051片外数据存储器的寻址空间为`0000H~0FFFFH`

4. 位地址`07H`位于字节地址`20H`, 位地址`7FH`位于字节地址`2FH`。
   
   片内RAM中`20H~2FH`这16个单元即可进行共128位的位寻址, 也可进行字节寻址。

   字节地址及其位地址见下表所示：

   |字节地址|D7|D6|D5|D4|D3|D2|D1|D0|
   |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
   |2FH|7FH|7EH|7DH|7CH|7BH|7AH|79H|78H|
   |2EH|77H|76H|75H|74H|73H|72H|71H|70H|
   |2DH|6FH|6EH|6DH|6CH|6BH|6AH|69H|68H|
   |...|...|
   |20H|07H|06H|05H|04H|03H|02H|01H|00H|

   因此`00H~07H`位于字节地址`20H`, `78H-7FH`位于字节地址`2FH`。

5. 访问外部存储器时, P0口用来传输低8位地址和数据, P2口用来传送高8位地址。

6. 访问外部存储器时, ALE的输出用于锁存低8位地址。

7. 一个机器周期为12个震荡周期

8. 为保证读入数据正确, 在读一个端口引脚之前应先向相应的端口锁存器写1。

   如果在读一个端口引脚之前向对应的输出锁存器写了0, 将总是读到0。

   8051访问片存储器时, 利用ALE信号锁存来自P0的低8位地址信号。

9. 只能用直接寻址方式访问特殊功能寄存器。

   如果为8052单片机, 在访问高128字节的RAM时, 只能用间接寻址方式寻址。
   
   访问片外数据存储器64Kbyte时, 使用DPTR做间接寻址寄存器。

   使用`MOVX @DPTR`类指令访问外部扩展存储器时, P2口输出高8位地址, P0口传送低8位地址和数据。

   8051中, `PC`和`DPTR`都用于提供地址时, `PC`是**用户程序不可访问的**,  `DPTR`可以分为两个8位寄存器`DPH`和`DPL`使用。

10. 累加器A的值为`30H`, 指令`MOVC A, @A+PC`位于地址`3000H`。执行该指令时, 程序存储器地址`3031H`的内容被传送至累加器A。

   指令`MOVC A, @A+PC`长度为1字节, 位于地址`3000H`, 因此PC值为`3001H`, 故`A+PC`为`3031H`。

11. 设SP的值为`5FH`, 指令`LCALL DELAY`所在地址为`2030H`, 子程序DELAY所在地址为`20A0H`, 则该指令完成的操作是将地址`2033H`压入堆栈保存, 将地址`20A0H`送入PC, SP的值应在该指令执行结束后变成`61H`。

   单片机执行子程序或中断服务程序时, 需要保护现场, 即将PC当前的值压栈保存, 当子程序或中断服务程序运行结束后再进行出栈。(所以如果子程序修改了栈的内容, 在子程序运行结束后程序有可能会运行错误）。

   **PC是16字节寄存器**, 所以SP需要加2, 以此分别保存PC的高、低8位的数据。

   `LCALL addr16`这条指令占3字节, 其中addr16占两字节, 因此程序可跳转64KB范围内的地址。

   (`ACALL`指令只能跳转当前所在的**2K范围内**的地址, 如果不涉及到片外数据存储器的话, 通常只用`SJMP`和`AJMP`)

> 在网上搜到的答案「将`3500H`送入PC」是错误的, 实际是将`20A0H`送入PC, 因为DELAY所在的地址为`20A0H`, 和`3500H`一点关系都没有。

12. `MOVC`访问**程序(ROM)**存储器, `MOVX`指令访问**外部数据**存储器。

   `MOVC`为查表指令, 只有`MOCV @A+PC`和`MOVC @A+DPTR`这两条, 均为单子节指令。

   `MOVX`用于累加器A与外部数据存储器进行传送。

   可以是`MOVX A, @DPTR`, `MOVX A, @Ri`, `MOVX @DPTR, A`, `MOVX @Ri, A`。

   当采用Ri作间接寻址时, 只能寻找片外256个单元的数据存储器, 此时8位地址和数据均由P0口传送。

23. 假设指令`DJNZ R7, rel`位于`005FH`, 如果在执行该指令前寄存器R7值为`00H`, 偏移量rel为`02H`, 则该指令执行后下一条要执行的指令所在的地址是`0063H`。

   `DJNZ R7, rel`位于`005FH`, 该指令长度为**2字节** (书上写的3字节是错的), 所以在执行这条指令开始时PC值在原来的基础上 + 2 变为`0061H`。又因为rel为`02H`, 所以执行这条指令后, PC值变为`0063H`。

24. 分析下面子程序的功能, 假设8051单片机的震荡频率为6MHz。

   ``` asm
  DL: MOV R7, #0AH
  L0: MOV R6, #250
  L1: NOP
        NOP
        DJNZ R6, L1
        DJNZ R7, L0
        RET
  ```

  R7为10, R6为250, 因此两个`NOP`加上一个`DJNZ`一共循环了250次, 该250次的循环一共执行了10次。

  `NOP`为1周期指令, `DJNZ`2周期指令, 两个`NOP`加一个`DJNZ`共4周期。

  6MHz下一个机器周期为12 / (6 \* 10^6)= 2微秒, 12MHz下一个机器周期为1微秒。

  故程序该子程序延时了4 \* 250 \* 10 \* 12 / (6 \* 10^6) = 20(ms)。

  (实际上有10次`MOV R6, #250`和10次`DJNZ R7, L0`造成的30个机器周期的约0.6ms的误差)

-----

> To be continued...