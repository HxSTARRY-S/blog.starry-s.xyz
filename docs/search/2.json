{"data":[{"title":"首页","url":"/","content":""},{"title":"标签","url":"/tags/","content":""},{"title":"Hello 2021","url":"/posts/hello-2021/","content":"\n\n\n\n\n \n\n\nconst ap0 = new APlayer ({\n    container: document.getElementById(\"aplayer0\"),\n    theme: \"#33363b\",\n    fixed: false,\n    listFolded: false,\n    listMaxHeight: false,\n    lrcType: false,\n    mini: false,\n    volume: 0.7,\n    order: \"list\",\n    loop: \"all\",\n    autoplay: false,\n    audio: [{\n        name: \"カイネ／救済\",\n        artist: \"MONACA / 岡部啓一\",\n        url: \"https://music.starry-s.me/music/530b_565e_0358_dacd477cbca4bc1acf8f4293c7685998.m4a\",\n        cover: \"https://music.starry-s.me/music/cover/2356253418376742.png\",\n        lrc: \"\",\n        theme: \"#666666\"\n    }]\n});\n  \n\n本来我已经戴好耳机准备睡觉了的，突然想起来2020年的年终总结还没有写，恰好脑子里有想写的东西，于是大概构思了一下，便从床上爬起来开灯打开电脑开写年终总结。\n因为思路不是很稳定，总是写了删删了写，所以隔了这么久才把原本已经放弃了不打算写的年终总结重新写出来。\n果然还是深夜适合写这些东西。\n今年原本打算能像去年那样在假期外出旅行的，然而疫情爆发后我就一直窝在家待着哪里都没去，不过在1月17号也就是武汉封城前几天，我自己一个人坐飞机跑去北京玩了一圈，当时还不知道有疫情这么一回事，到北京后就是找个地方住下，简单的去了一些景点，后来因为脚疼，很多路远的人多的地方都没有去成。在北京闲逛3天后就坐大客车回家了（一边坐车一遍骂京哈高铁京承段为什么一点进展都没有）。到家后不几天就听说武汉开始封城，然后北京就开始交通管制，现在想想还挺刺激的。\n然后暑假本来打算去上海BW2020的，在票都买好了之后，因为外出需要和学校审批（此处省略若干字），最终漫展门票全打水漂，飞机票退票手续费还花了三百多块钱。\n上半年宅在家里大半年，几乎是什么都没学，什么事情都没干。不过也借此机会每天都能睡个大懒觉，总之就是狠狠的歇了一顿，尝试着把高中时期欠的觉补回来，然而似乎并不管用。\n然后总感觉自己每天都很累，明明什么都没有干但是身体总是一点力气都没有，总之下半年开学后经历了很长一段时间才重新适应了学校的生活，期间心理变化很复杂。\n所以大二下学期和大三上学期的期末成绩基本上都是刚好及格。（真的是烤60分比烤80分还高兴）\n\n年初看了几集超电磁炮3，看到后来因为它更新太慢了就忘了继续看了。之后还看了格莱普尼尔，看这个番纯粹是因为它的OP是Hikaru唱的，看着看着觉得挺有意思而且官方更新速度很快，于是就把第一季追完了。\n然后因为Lacrimosa这首歌，我才看的黑执事，不过自己比较懒只看了第一季，第二季一直咕到现在都没有看，听说剧情挺虐的所以我更不敢看了。（明明第二季的ed比第一季的还好听）\n本来还打算看新世纪福音战士的，也是因为懒，看了一集就不继续看了。\n除此之外，年末的时候在睡前为了打发时间看了几集非自然死亡。\n\n这一年又打了一遍尼尔：机械纪元。和第一次玩不太一样，二刷时我尽可能的多做支线任务，不开简单模式和自动芯片。不过通关后我还没有打E结局，总想找个时间把其他支线任务做完。\n年初在逛淘宝时发现了台版的尼尔原著小说，于是毫不犹豫的把少年寄叶、短话和长话全都买了下来。不过截至目前我只看完了短话。在看完艾米尔的回忆那一章后很感动于是打开游戏找到相对应的支线任务，废了很大力气找到那三朵“Luna Tear”（月之泪）之后，前往种着一大片月之泪的地下室。\n在网上看攻略找到了艾米尔居住的家，于是又走了很远的路到地下很深的地方，到他家里面拿（偷）走了面具。\n据说去他家偷完东西后会触发艾米尔的boss支线，不过因为在寝室没太多时间所以我没有继续玩下去。\n蛮期待2021年4月发行的尼尔续作的，不过有些担心我的笔记本还能不能跑得起来。\n\n尝试着二刷空境原著，不过没刷完，所以只好等以后有时间再看了。\n2020年下半年花了很大力气尝试玩懂FGO，不过最终因为太肝、自己太非、没时间而劝退，前几章的主线太枯燥乏味了，而且我貌似只对FSN系列和空境系列的人感兴趣，FGO里面的人物基本和他们不沾边而且我也不认识。\n很期待月姬重制版，尽管我目前还一点都不了解月姬。既然月姬重置版只在主机平台上映，尼尔续作也有主机版，那么我是不是应该提前准备一台PS4呢？\nPS5水货太贵了还是算了，除非等国行，然而等国行又要等到4月份。\n关键是我连PS4都买不起。\n\n2020年4月份的时候新开了一个Minecraft单机生存的坑，原本是打算看一下新版本（1.15.2）更新了什么新特性的（蜜蜂），结果玩上生存就停不下来了。先是花了两个星期用纯铁镐手挖两个史莱姆区块，用矿车运村民和僵尸照着B站的视频建了简易的刷铁机，之后又用不到一个月的时间解放末地。总之就是玩上了就停不下来了。然后照着B站各大UP主的视频做了末地刷沙机、然后是混凝土固化机，后来挂三向轰炸机肝了3天清了出生点空置域。用了短短几个月的时间一个人建了很多东西，去地狱打了凋零骷髅头，建海上刷怪塔刷火药和骨粉。后来物资储备足够多了之后就开始挖地铁（旧习难改吧），一年的时间挖了两条地铁线路，盖了十几座车站、一座跨海大桥、一栋摩天大楼。\n原来单机生存还能玩得这么有意思，B站上有很多生电大佬，然而红科搬的视频我基本都看不懂。\n后续可能要再修几条地铁，延长已有的线路，然后再搞一些建筑，炸一个原点空置域修全物品分类机，然后还打算升级1.16.4。\n\n就回忆到这里吧，2020是个特别的一年。\n\n"},{"title":"51单片机习题整理","url":"/posts/learn-mcs8051/","content":"\n\n赶在期中考试(骑磨烤柿)前把单片机的课后习题整理出来...\n(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧...)\n\n\n\n\n本篇内容为作者整理资料所得, 仅供学习使用。如需转载请务必遵循CC BY-NC-ND 4.0协议。\n请勿将本篇内容作为权威的教学辅导资料使用, 因无法保证100%准确, 仅供参考。\n如果发现了本篇存在的错误, 欢迎在页面下方提issue指正。\n本篇文章使用MathJax显示数学公式，在使用RSS阅读器时会出现无法正确显示的情况。\n\n\n\n \n\n\nconst ap0 = new APlayer ({\n    container: document.getElementById(\"aplayer0\"),\n    theme: \"#33363b\",\n    fixed: false,\n    listFolded: false,\n    listMaxHeight: false,\n    lrcType: false,\n    mini: false,\n    volume: 0.7,\n    order: \"list\",\n    loop: \"all\",\n    autoplay: false,\n    audio: [{\n        name: \"春はゆく\",\n        artist: \"Aimer\",\n        url: \"https://music.starry-s.me/music/obj_wonDkMOGw6XDiTHCmMOi_1630142819_fc9d_8785_4c2c_8abd7ec40b9695cbf53de173e782f195.m4a\",\n        cover: \"https://music.starry-s.me/music/cover/109951164785068521.jpg\",\n        lrc: \"\",\n        theme: \"#25AFF5\"\n    }]\n});\n  \n\n硬件结构&amp;指令系统\n\n8051复位后从地址0000H开始执行程序, SP的值为07H。\nPC: 两字节(16位)寄存器, 也称程序计数器。\nSP: 堆栈指针, 指示出堆栈顶部在内部RAM块中的位置。\n单片机的堆栈设在了内部RAM区, 单片机复位后, SP中的内容为07H(指向第0组工作寄存器的R7), 堆栈实际上从08H开始。\n若SP被初始化为39H, 则堆栈实际上是从3AH开始的。\n执行LCALL addr16指令时，单片机先将PC的低字节压栈，再将PC的高字节压栈，最后把转移地址送入PC中。\n与之类似的LJMP类无条件转移指令，单片机只修改PC的值，并不堆栈保存跳转前的PC中保存的地址。\n执行RET指令后, SP值减2 (因为PC为2字节寄存器), 进行两次出栈操作，第一次出栈送PC的高位，第二次出栈送PC的低位。\n中断服务程序结束指令RETI不仅将堆栈中保存的2字节地址分别送入PC的高位和低位中，而且复位中断系统。因此RET和RETI不同。\nRET和RETI对堆栈的操作是相同的。\n\nPSW中的RS1 RS0=10B时, R2的RAM地址为12H。\nPSW： 程序状态字寄存器, 从PSW.7至PSW.0分别为Cy(进位标志位), Ac(辅助进位标志位), F0(标志位), RS1和RS0(寄存器区选择控制位), OV(溢出位), 保留位, P(奇偶标志位, 奇数为1, 偶数为0)。\n\n\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nPSW\nCy\nAc\nF0\nRS1\nRS0\nOV\n\nP\n\n\nRS1 RS0 = 10B时, 使用第二组工作寄存器区, 第0组工作寄存器区R0-R7的地址为00H-07H, 第1组为08H-0FH, 第2组为10H-17H, 第3组为18H-1FH(每组长度为8个字节, 每个寄存器占1个字节)。\n因此, 当A为01110010B时, PSW中P为0(偶数个1)。\nINC A指令不改变PSW中的Cy，只有可能改变奇偶标志位P。\n假设PSW为18H, 即00011000B, 此时使用第3组工作寄存器, R0地址为18H, R7地址为1FH。\n复位后, 默认选择的寄存器区是0区。\n\n8051片外数据存储器的寻址空间为0000H~0FFFFH\n\n位地址07H位于字节地址20H, 位地址7FH位于字节地址2FH。\n片内RAM中20H~2FH这16个单元即可进行共128位的位寻址, 也可进行字节寻址。\n字节地址及其位地址见下表所示：\n\n\n\n字节地址\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\n2FH\n7FH\n7EH\n7DH\n7CH\n7BH\n7AH\n79H\n78H\n\n\n2EH\n77H\n76H\n75H\n74H\n73H\n72H\n71H\n70H\n\n\n2DH\n6FH\n6EH\n6DH\n6CH\n6BH\n6AH\n69H\n68H\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n21H\n0FH\n0EH\n0DH\n0CH\n0BH\n0AH\n09H\n08H\n\n\n20H\n07H\n06H\n05H\n04H\n03H\n02H\n01H\n00H\n\n\n因此00H~07H位于字节地址20H, 78H-7FH位于字节地址2FH。\n除此之外，一些特殊功能寄存器（SFR）可进行位寻址（字节地址能够被8整除），SFR中位地址有83个（共有88个，5个未用），能够位寻址的SFR的字节地址末位均为0H或8H。\n\n访问外部存储器时, P0口用来传输低8位地址和数据, P2口用来传送高8位地址。\n\n访问外部存储器时, ALE的输出用于锁存低8位地址。\n\n一个机器周期为12个震荡周期\n\n为保证读入数据正确, 在读一个端口引脚之前应先向相应的端口锁存器写1。\n如果在读一个端口引脚之前向对应的输出锁存器写了0, 将总是读到0。\n8051访问片外存储器时, 利用ALE信号锁存来自P0的低8位地址信号。\n\n只能用直接寻址方式访问特殊功能寄存器。\n如果为8052单片机, 在访问高128字节的RAM时, 只能用间接寻址方式寻址。\n访问片外数据存储器64Kbyte时, 使用DPTR做间接寻址寄存器。\n使用MOVX @DPTR类指令访问外部扩展存储器时, P2口输出高8位地址, P0口传送低8位地址和数据。\n8051中, PC和DPTR都用于提供地址时, PC是用户程序不可访问的, DPTR可以分为两个8位寄存器DPH和DPL使用。\n\n累加器A的值为30H, 指令MOVC A, @A+PC位于地址3000H。执行该指令时, 程序存储器地址3031H的内容被传送至累加器A。\n指令MOVC A, @A+PC长度为1字节, 位于地址3000H, 因此PC值为3001H, 故A+PC为3031H。\n\n设SP的值为5FH, 指令LCALL DELAY所在地址为2030H, 子程序DELAY所在地址为20A0H, 则该指令完成的操作是将地址2033H压入堆栈保存, 将地址20A0H送入PC, SP的值应在该指令执行结束后变成61H。\n单片机执行子程序或中断服务程序时, 需要保护现场, 即将PC当前的值压栈保存, 当子程序或中断服务程序运行结束后再进行出栈。(所以如果子程序修改了栈的内容, 在子程序运行结束后程序有可能会运行错误)。\nPC是16字节寄存器, 所以SP需要加2, 以此分别保存PC的高、低8位的数据。\nLCALL addr16这条指令占3字节, 其中addr16占两字节, 因此程序可跳转64KB范围内的地址。\n(ACALL指令只能跳转当前所在的2K范围内的地址, 如果不涉及到片外数据存储器的话, 通常只用SJMP和AJMP)\n\n在网上搜到的答案「将3500H送入PC」是错误的, 实际是将20A0H送入PC, 因为DELAY所在的地址为20A0H, 和3500H一点关系都没有。\n\n\nMOVC访问 程序(ROM) 存储器, MOVX指令访问 外部数据 存储器。\nMOVC为查表指令, 只有MOVC @A+PC和MOVC @A+DPTR这两条, 均为单字节指令。\nMOVX用于累加器A与外部数据存储器进行传送。\n可以是MOVX A, @DPTR, MOVX A, @Ri, MOVX @DPTR, A, MOVX @Ri, A，其中i为0或1.\n当使用MOVX @Ri类指令时，只有P0口用来传送地址和数据，P2口的状态不会发生改变，因此可使用MOV P2, #12H指令设定高8位的地址。\n当采用Ri作间接寻址时, 只能寻找片外256个单元的数据存储器, 此时8位地址和数据均由P0口传送，P2口的状态不发生改变。\n\n假设指令DJNZ R7, rel位于005FH, 如果在执行该指令前寄存器R7值为00H, 偏移量rel为02H, 则该指令执行后下一条要执行的指令所在的地址是005FH。\nDJNZ R7, rel位于005FH, 该指令长度为2字节 (书上写的3字节是错的), 所以在执行这条指令开始时PC值在原来的基础上 + 2 变为0061H。又因为rel为02H, 所以执行这条指令后, PC值变为0063H。\n\n分析下面子程序的功能, 假设8051单片机的震荡频率为6MHz。\n1\n2\n3\n4\n5\n6\n7DL: MOV R7, #0AH\nL0: MOV R6, #250\nL1: NOP\n    NOP\n    DJNZ R6, L1\n    DJNZ R7, L0\n    RET\nR7为10, R6为250, 因此两个NOP加上一个DJNZ一共循环了250次, 该250次的循环一共执行了10次。\nNOP为1周期指令, DJNZ为2周期指令, 两个NOP加一个DJNZ共4周期。\n6MHz下一个机器周期为 $12 \\div (6 \\times 10^6)= 2{\\mu}s$, 12MHz下一个机器周期为1微秒。\n故程序该子程序延时了$(4 \\times 250 \\times 10 \\times 12) \\div (6 \\times 10^6) = 20(ms)$。\n(实际上有10次MOV R6, #250和10次DJNZ R7, L0造成的30个机器周期的约0.6ms的误差)\n\n\n\n\n以下部分写于2020年11月25日\n\n汇编语言程序\n\n编写一个子程序, 将内部RAM 40H~4FH的内容复制到50H~5FH。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11COPY: MOV R0, #40H\n      MOV R1, #50H\n      MOV R2, #10H\n      ; 40H~4FH一共复制了16次\nLOOP:\n      MOV A, @R0\n      MOV @R1, A\n      INC R0\n      INC R1\n      DJNZ R2, LOOP\n      RET\n因为没有MOV @RX, @RX这条指令, 所以用A做数据的中转站。\n\n将任何无符号8位二进制数转换为BCD码的子程序, 入口参数为内部RAM单元20H, 出口参数为内部RAM单元30H和31H, 30H存放百位数, 31H存放十位数和个位数。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15CV:\nMOV R0, #20H\nMOV A, @R0\nMOV B, #100\nDIV AB; A除以100, 得到的百位数存在A中\nMOV 30H, A\nMOV A, B\n\nMOV B, #10\nDIV AB\n\nSWAP A\nADD A, B; 也可以用ORL\nMOV 31H, A\nRET\nDIV AB和MUL AB的A和B之间没有逗号。\n\n内部RAM 30H单元存放两位十进制数 (压缩BCD码), 编写将该十进制数转换为对应ASCII码的子程序, 转换结果存放到内部RAM 40H (十位数) 和41H (个位数) 单元。\n\nASCII码： 30H为0, 41H为A, 61H为a\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17CV:\nMOV A, 30H\nANL A, #0FH\nMOV DPTR, #DATA; 或者直接用ADD A, #30H即可\nMOVC A, @A+DPTR\nMOV 41H, A\n\nMOV A, 30H\nSWAP A\nANL A, #0FH\nMOVC A, @A+DPTR\nMOV 40H, A\n\nRET\n\nDATA:\nDB 30H, 31H, 32H, 33H, 34H, 35H, 36H, 37H, 38H, 39H\n\n8个8位数相加, 求平均值, 入口地址为30H~37H, 结果存到40H。\n把8位数相加存在溢出, 所以把相加结果以16进制存到R2、R3中, 再除以8( 右移3次), 即可求得不四舍五入的平均值。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15MOV R0, #30H\nMOV R1, #08H\nMOV R2, #00H\nMOV R3, #00H\n; 初始化\nLOOP:\nCLR C\nMOV A, @R0\nADD A, R3\nMOV R3, A\nJNC SKIP\nINC R2\nSKIP:\nINC R0\nDJNZ R1, LOOP   \n这样结果被保存到R2、R3中, 然后需要写一个循环右移3位的程序。\n1\n2\n3\n4\n5\n6\n7\n8MOV R4, #03H\nLOOP2:\nRRC R2\nRRC R3\nDJNZ R4, LOOP2\n\nMOV 40H, R3\n; 右移3次后R2的低4位为0, 结果保存在R3中\n这样R3中求得的是不带四舍五入的结果。\n如果需要带四舍五入的话第一种方法是判断最后一次右移时最低位是否为$1$， ($1 / 2 = 0.5$)。   \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11MOV R4, #03H\nLOOP2:\nRRC R2\nRRC R3\nDJNZ R4, LOOP2\n\nJNC SKIP2\nINC R3\nSKIP2:\nMOV 40H, R3\n; 右移3次后R2肯定为0\n这样是带四舍五入的结果。\n第二种方法，8个8位数相加求平均值，要求四舍五入的话，只需要在这8个数求和后再加4（0100B），之后右移3次。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11ADD A, #04H\nMOV R3, A\nJNC SKIP2\nINC R2\n\nSKIP2:\nMOV R4, #03H\nLOOP2:\nRRC R2\nRRC R3\nDJNZ R4, LOOP2\n结果保存在R3中。\n\n\n\n中断系统\n\n8051的外部中断有低电平触发和下降沿触发两种触发方式。外部中断1的中断向量地址是0013H。\n在响应中断时, 单片机自动生成一条长调用指令LCALL addr16, 其地址为中断入口地址。\n\n\n\n中断源\n入口地址\n\n\n\nINT0\n0003H\n\n\nT0\n000BH\n\n\nINT1\n0013H\n\n\nT1\n001BH\n\n\n串行口\n0023H\n\n\n通常在中断入口地址处放一条无条件转移指令*JMP。\n内部查询顺序同入口地址的顺序，由高到低。\n\n执行指令MOV IP, #0BH( #00001011B)后, 中断优先级最高者为PX0, 最低为PS。\nIP: 中断优先级寄存器, 其前3为无意义, 后5位( IP.4至IP.0)为：PS, PT1, PX1, PT0, PX0, 分别对应串行口、定时器T1、外部中断1、定时器0、外部中断0。\n\n\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nIP\n\n\n\nPS\nPT1\nPX1\nPT0\nPX0\n\n\n单片机复位以后, IP的内容为0, 各个中断源均为低优先级中断。\n在同时收到几个同一优先级的中断请求时, 中断响应取决于内部查询顺序, 其顺序由高到低为：INT0、T0、INT1、T1、串行口。\n当中断源均为同一优先级时, 当它们同时申请中断时CPU首先响应外部中断0\n\n8051的晶振频率为12MHz, 则最短的外部中断响应时间为3${\\mu}$s, 最长的外部中断响应时间为12${\\mu}s$。\n\n中断标记位于单片机寄存器的TCON和SCON中。\n\n\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nTCON\nTF1\nTR1\nTF0\nTR0\nIE1\nIT1\nIE0\nIT0\n\n\nSCON\nSM0\nSM1\nSM2\nREN\nTB8\nRB8\nTI\nRI\n\n\nTCON中TF1和TF0为定时器/计数器中断标志位, TR1和TR0为定时/计数启动位, IE1和IE0为外部中断标志位, IT1和IT0为选择外部中断为边沿触发(1)还是电平触发(0)方式。\nSCON中前几位与串行口有关，第1位和第2位的TI和RI(是大写字母I不是数字1)分别为串行口中断发送中断请求标志位(发送成功后置1)和接受中断请求标志位( 接受成功后置1)。串口中断无法硬件清零, 只能软件清零。\n当IE中EA为1、ES为1时，TI或RI为1时，CPU执行无条件转移指令LJMP 0023H, 执行串行口中断服务程序。\n\n要使8051能够响应定时器T1的中断和串行口中断, 不响应其他中断, 则中断允许寄存器IE的内容为98H(10011000B)。\n中断允许寄存器IE：\n\n\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nIE\nEA\n\n\nES\nET1\nEX1\nET0\nEX0\n\n\nEA为总控制位, 当EA为1时, CPU才可以响应中断请求。\nES为串行口中断允许位, ET1和ET0为定时器中断允许位, EX1和EX0为外部中断允许位。\n\n\n\n定时器和计数器\n\n使T0工作方式1的溢出周期最长的初值是0000H。\n定时器/计数器工作在方式0为13位计数器, 由TLX的低5位和THX的高8位组成13位计数器, 最大值为$2^{13}-1 = 8191$, 晶振频率12MHz下计时周期最长为8.192ms。工作在方式1时由均为8位的TLX和THX组成16位计数器, 最大值为65535, 晶振频率为12M下最长为65.536ms。\n当定时器/计数器工作在方式2时, 可以循环定时/计数。当计数溢出后, 自动将8位的THX装入8位的TLX中, 可省去重装初值的时间, 最大值为255, 晶振频率12M下计时周期最长为0.256ms。\n\nT1配置为方式3时, 停止计数, 方式3只适用于定时器0。\n定时器T0的方式3将其分为两个8位定时器, 其中TH0只能做定时器使用。\n\n设8051单片机的晶振频率为12MHz, 定时器作计数器使用时, 其计数输入信号的最高频率为500KHz。\n当定时器用作计数器时, 当检测到引脚上的负跳变时计数器的值增一。检测下降沿需要2个机器周期, 即24个震荡周期, 所以输入信号最高频率为 $12M \\div 24 = 500KHz$。\n\n用定时器方式2扩展一个下降沿触发的外部中断, 计数初值应为FFH。\n此处定时器2以计数器方式运行, 当检测到一个下降沿后, 计数器加一后溢出, 因此会执行定时器中断的中断子程序。\n\n\n\n\n2020年12月3日：\n前两天感冒, 休息了几天(打了两天的游戏)后继续。\n\n串行口\n\n串行口TXD为高电平, 表示这是数据位或停止位或空闲状态。\n串行口工作在方式1时, TXD用来发送数据、RXD用来接受数据。方式1的一帧数据为10位, 起始为为0, 停止位为1, 数据位和空闲状态均可能为0或1。\n\n串行口工作在方式3时, 发送的第9位数据要事先写入寄存器SCON的TB8, 接收的第9位数据被写入同一寄存器的RB8。\n串行口控制寄存器SCON：\n\n\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nSCON\nSM0\nSM1\nSM2\nREN\nTB8\nRB8\nTI\nRI\n\n\n其中SM0、SM1为串口的工作方式选择位, 方式0为同步移位寄存器方式, 方式1为8位异步收发, 方式2和方式3为9位异步收发。\n波特率：串行口每秒钟传送的比特位数，单位bits/s。\n方式0的波特率固定为 $f_{osc}/12$, 方式2的波特率为 $f_{osc}/64$ 或 $f_{osc}/32$ (由SMOD控制)。\n方式1的波特率和方式3的波特率可变, 公式为 $(2^{SMOD} / 32) \\times 定时器T1的溢出率$。\nT1的溢出率为定时器T1的周期的倒数，定时器的周期为 \n$$T = \\frac{12\\times (2^n - X )}{f_{osc}}$$\n当T1工作在方式2时，n为8，波特率为：\n$$波特率=\\frac{(2^{SMOD} \\div 32) \\times f_{osc}}{12 \\times (256 - X)}$$\n$X$为定时器T1的初值。\n串口工作在方式1，波特率为2400，则每秒钟最大能发送/接收 $2400 \\div 10 = 240Byte$的数据。\n\n单片机工作在方式1时, 1帧数据为1个起始位、8个数据位、1个停止位共10位。\n\n8051的UART工作在方式3，要求每秒钟能传送不少于900个字节的数据，则波特率应当大于 $900 \\times 8 = 7200bits/s$。\n\n比特率2400Kbits/s，时钟频率12M，PC机发送8个字节的数据存到单片机的30H-37H中，随后单片机发送2个确认字节55H和AAH给PC机，使用查询方式。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34ORG 0000H\nMAIN:\nMOV SCON, #50H\n; 串口使用方式1，且允许接收\nMOV PCON, #00H\n; 波特率不加倍\nMOV TMOD, #20H\n; 定时器1使用方式2\n\nMOV TL1, #0F3H\nMOV TH1, #0F3H\nSETB TR1\n\nLOOP:\nMOV R0, #30H\nMOV R1, #08H\n\nREC:\nJNB RI, $\nMOV @R0, SBUF\nCLR RI ; 软件清零RI\nINC R0\nDJNZ R1, REC\n\nMOV SBUF, #55H\nJNB TI, $\nCLR TI\n\nMOV SBUF, #0AAH\nJNB TI, $\nCLR TI\nAJMP LOOP\n\nEND\n单片机接收到数据后，RI被置1，代表SBUF中的数据有效，取走SBUF中的数据后需要软件清零RI（串口中断不会自动清零RI）。\n当单片机执行写SBUF操作时，串口发送开始，TI被自动置1，在发送完成后TI被自动清0。\n\n\n\n\n2020年12月7日：\n\nI/O口 &amp; 外部存储器拓展\n\n8051使用指令MOVX A, @R0读外部数据存储器时，不起作用的信号是WR。\n8051在使用MOVX @DPTR类指令读外部数据存储器时，P0和P2先输出外部数据的地址，单片机发出的ALE信号的负跳沿将P0口输出的地址锁存在地址锁存器(74HC573)里，之后单片机发出RD信号，读取外部数据存储器（RAM）的数据到总线再传送到P0口上。最后单片机从P0口读取数据保存到A中。\n如果是写外部数据存储器时，单片机将不发出RD信号而是WR信号，将A中的数据写入外部数据存储器中。\n\n存储器芯片6264需要13根地址线。\n62256的容量为 $256Kbit \\div 8 = 32KB = 2^{15}$, 需要15根地址线。\n6264的容量为 $64Kbit \\div 8 = 8KB = 2^{13}$，所以需要13根地址线。\n6116容量为 $16Kbit \\div 8 = 2KB = 2^{11}$, 需要11根地址线。\n计算方法是62$X$的 $容量=X \\div 8(K)$。\n\n使用16位地址模式时，8051的外部数据存储器寻址空间为64KB。\n\n基于8051的单片机系统能拓展的外部数据存储器容量无限制。\n有的书上说最大只能拓展64KB，实际是最大寻址空间为64KB，拓展的外部数据存储器容量无限制。\n\n8051的程序存储器可用来存放用户程序和数据。 例如使用DW或DB指令用来定义数据。\n所以应用程序也可以使用MOVC A, @A+DPTR访问程序存储器中的数据。\n\n\n\n除此之外LED数码管和外部存储器拓展、外部I/O设备拓展部分有很多需要根据线路图计算地址和DA转换的题，因为线路图源自老师提供的PDF，而老师为PDF加了密码，意味着不允许外传，所以我就不放到博客上面了，除非我自己用Porteus画一个类似的\n\n\nLED段码入口地址8004H，位选入口地址8002H，将30H-32H保存的6个压缩BCD码发送到6位共阴极数码管上显示， 要求编写延时1ms的子程序。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62MAIN:\nMOV R0, #30H\n; R2用来计数\nMOV R2, #03H\n; R3用来位选\nMOV R3, #01H\n\nLOOP:\nMOV A, @R0\nSWAP A\nANL A, #0FH\nMOV DPTR, #TAB\nMOVC A, @A+DPTR\n; 取高4位BCD码对应的段码\n\nMOV DPTR, #8004H\nMOVX A, @A+DPTR\n; 先送段码\n\nMOV A, R3\nMOV DPTR, #8002H\nMOVX @DPTR, A\nRL A\nMOV R3, A\n; 再送位选\n\nLCALL DELAY\n\nMOV A, @R0\nANL A, #0FH\nMOV DPTR, #TAB\nMOVC A, @A+DPTR\n; 取低4位BCD码对应的段码\n\nMOV DPTR, #8004H\nMOVX A, @A+DPTR\n; 送段码\n\nMOV A, R3\nMOV DPTR, #8002H\nMOVX @DPTR, A\nRL A\nMOV R3, A\n; 送位选\n\nLCALL DELAY\nINC R0\n\nDJNZ R2, LOOP\n\nDELAY:\nMOV R7, #250\nDL:\nNOP\nNOP\nDJNZ R7, DL\nRET\n\nTAB:\nDB 3FH, 06H, 5BH, 4FH, 66H, 6DH, 7DH, 07H, 7FH, 6FH\n\nEND\n\n打印机数据输入接口和P1直接相连，STB接口和P3.4相连，BUSY接口和P3.3相连，不使用ACK应答信号，编写将外部存储器1000H-100FH的数据发送到打印机打印的子程序。\n\n \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14PRINT:\nMOV DPTR, #1000H\nMOV R2, #10H\n\nLOOP:\nJB P3.3, $\n; 确保打印机处于空闲状态\nMOVX A, @DPTR\nMOV P1, A\nCLR P3.4\nSETB P3.4\nINC DPTR\nDJNZ R2, LOOP\nRET\n如果打印机没有和P1直接相连，而是连接到数据锁存器上（74HC374），锁存器的时钟信号的入口地址为A000H。\n使用堆栈保护间接寻址寄存器的值。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20PRINT:\nMOV R2, #10H\nMOV DPTR, #1000H\nLOOP:\nJB P3.3, $\n; 确保打印机处于空闲状态\n\nMOVX A, @DPTR\nPUSH DPL\nPUSH DPH\nMOV DPTR, #0A000H\nMOVX @DPTR, A\nPOP DPH\nPOP DPL\n\nCLR P3.4\nSETB P3.4\nINC DPTR\nDJNZ R2, LOOP\nRET\n\n\n\nSFR列表\n\n\n\n87H\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nPCON\nSMOD\n-\n-\n-\n-\n-\nPD\nIDL\n\n\n\n\n\n\n\n88H\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nTCON\nTF1\nTR1\nTF0\nTR0\nIE1\nIT1\nIE0\nIT0\n\n\n\n\n\n\n\n89H\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nTMOD\nGATE\nC/T\nM1\nM0\nGATE\nC/T\nM1\nM0\n\n\n\n\n\n\n\n98H\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nSCON\nSM0\nSM1\nSM2\nREN\nTB8\nRB8\nTI\nRI\n\n\n\n\n\n\n\nA8H\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nIE\nEA\n-\n-\nES\nET1\nEX1\nET0\nEX0\n\n\n\n\n\n\n\nB8H\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nIP\n-\n-\n-\nPS\nPT1\nPX1\nPT0\nPX0\n\n\n\n\n\n\n\nD0H\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nPSW\nCy\nAc\nF0\nRS1\nRS0\nOV\n-\nP\n\n\n\n"}]}