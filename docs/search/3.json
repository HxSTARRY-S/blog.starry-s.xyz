{"data":[{"title":"51单片机习题整理","url":"/posts/learn-mcs8051/","content":"\n\n赶在期中考试(骑磨烤柿)前把单片机的课后习题整理出来...\n(实在是没什么可拿来更新博客的了, 就干脆写点复习资料吧...)\n\n\n\n\n本篇内容为作者整理资料所得, 仅供学习使用。如需转载请务必遵循CC BY-NC-ND 4.0协议。\n请勿将本篇内容作为权威的教学辅导资料使用, 因无法保证100%准确, 仅供参考。\n如果发现了本篇存在的错误, 欢迎在页面下方提issue指正。\n\n\n\n \n\n\nconst ap0 = new APlayer ({\n    container: document.getElementById(\"aplayer0\"),\n    theme: \"#33363b\",\n    fixed: false,\n    listFolded: false,\n    listMaxHeight: false,\n    lrcType: false,\n    mini: false,\n    volume: 0.7,\n    order: \"list\",\n    loop: \"all\",\n    autoplay: false,\n    audio: [{\n        name: \"春はゆく\",\n        artist: \"Aimer\",\n        url: \"https://music.starry-s.me/music/obj_wonDkMOGw6XDiTHCmMOi_1630142819_fc9d_8785_4c2c_8abd7ec40b9695cbf53de173e782f195.m4a\",\n        cover: \"https://music.starry-s.me/music/cover/109951164785068521.jpg\",\n        lrc: \"\",\n        theme: \"#25AFF5\"\n    }]\n});\n  \n\n硬件结构&amp;指令系统\n\n8051复位后从地址0000H开始执行程序, SP的值为07H。\nPC: 两字节(16位)寄存器, 也称程序计数器。\nSP: 堆栈指针, 指示出堆栈顶部在内部RAM块中的位置。\n单片机的堆栈设在了内部RAM区, 单片机复位后, SP中的内容为07H(指向第0组工作寄存器的R7), 堆栈实际上从08H开始。\n若SP被初始化为39H, 则堆栈实际上是从3AH开始的。\n执行RET指令后, SP值减2 (因为PC为2字节寄存器), 将调用指令的下一条指令的首地址送入PC中。\n\nPSW中的RS1 RS0=10B时, R2的RAM地址为12H。\nPSW： 程序状态字寄存器, 从PSW.7至PSW.0分别为Cy(进位标志位), Ac(辅助进位标志位), F0(标志位), RS1和RS0(寄存器区选择控制位), OV(溢出位), 保留位, P(奇偶标志位, 奇数为1, 偶数为0)。\n\n\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nPSW\nCy\nAc\nF0\nRS1\nRS0\nOV\n\nP\n\n\nRS1 RS0 = 10B时, 使用第二组工作寄存器区, 第0组工作寄存器区R0-R7的地址为00H-07H, 第1组为08H-0FH, 第2组为10H-17H, 第3组为18H-1FH(每组长度为8个字节, 每个寄存器占1个字节)。\n因此, 当A为01110010B时, PSW中P为0(偶数个1)。\nINC A指令不改变PSW中的Cy，只有可能改变奇偶标志位P。\n假设PSW为18H, 即00011000B, 此时使用第3组工作寄存器, R0地址为18H, R7地址为1FH。\n复位后, 默认选择的寄存器区是0区。\n\n8051片外数据存储器的寻址空间为0000H~0FFFFH\n\n位地址07H位于字节地址20H, 位地址7FH位于字节地址2FH。\n片内RAM中20H~2FH这16个单元即可进行共128位的位寻址, 也可进行字节寻址。\n字节地址及其位地址见下表所示：\n\n\n\n字节地址\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\n2FH\n7FH\n7EH\n7DH\n7CH\n7BH\n7AH\n79H\n78H\n\n\n2EH\n77H\n76H\n75H\n74H\n73H\n72H\n71H\n70H\n\n\n2DH\n6FH\n6EH\n6DH\n6CH\n6BH\n6AH\n69H\n68H\n\n\n...\n...\n\n\n\n\n\n\n\n\n\n20H\n07H\n06H\n05H\n04H\n03H\n02H\n01H\n00H\n\n\n因此00H~07H位于字节地址20H, 78H-7FH位于字节地址2FH。\n除此之外，一些特殊功能寄存器（SFR）可进行位寻址（字节地址能够被8整除），SFR中位地址有83个（共有88个，5个未用），能够位寻址的SFR的字节地址末位均为0H或8H。\n\n访问外部存储器时, P0口用来传输低8位地址和数据, P2口用来传送高8位地址。\n\n访问外部存储器时, ALE的输出用于锁存低8位地址。\n\n一个机器周期为12个震荡周期\n\n为保证读入数据正确, 在读一个端口引脚之前应先向相应的端口锁存器写1。\n如果在读一个端口引脚之前向对应的输出锁存器写了0, 将总是读到0。\n8051访问片外存储器时, 利用ALE信号锁存来自P0的低8位地址信号。\n\n只能用直接寻址方式访问特殊功能寄存器。\n如果为8052单片机, 在访问高128字节的RAM时, 只能用间接寻址方式寻址。\n访问片外数据存储器64Kbyte时, 使用DPTR做间接寻址寄存器。\n使用MOVX @DPTR类指令访问外部扩展存储器时, P2口输出高8位地址, P0口传送低8位地址和数据。\n8051中, PC和DPTR都用于提供地址时, PC是用户程序不可访问的, DPTR可以分为两个8位寄存器DPH和DPL使用。\n\n累加器A的值为30H, 指令MOVC A, @A+PC位于地址3000H。执行该指令时, 程序存储器地址3031H的内容被传送至累加器A。\n指令MOVC A, @A+PC长度为1字节, 位于地址3000H, 因此PC值为3001H, 故A+PC为3031H。\n\n设SP的值为5FH, 指令LCALL DELAY所在地址为2030H, 子程序DELAY所在地址为20A0H, 则该指令完成的操作是将地址2033H压入堆栈保存, 将地址20A0H送入PC, SP的值应在该指令执行结束后变成61H。\n单片机执行子程序或中断服务程序时, 需要保护现场, 即将PC当前的值压栈保存, 当子程序或中断服务程序运行结束后再进行出栈。(所以如果子程序修改了栈的内容, 在子程序运行结束后程序有可能会运行错误)。\nPC是16字节寄存器, 所以SP需要加2, 以此分别保存PC的高、低8位的数据。\nLCALL addr16这条指令占3字节, 其中addr16占两字节, 因此程序可跳转64KB范围内的地址。\n(ACALL指令只能跳转当前所在的2K范围内的地址, 如果不涉及到片外数据存储器的话, 通常只用SJMP和AJMP)\n\n在网上搜到的答案「将3500H送入PC」是错误的, 实际是将20A0H送入PC, 因为DELAY所在的地址为20A0H, 和3500H一点关系都没有。\n\n\nMOVC访问 程序(ROM) 存储器, MOVX指令访问 外部数据 存储器。\nMOVC为查表指令, 只有MOCV @A+PC和MOVC @A+DPTR这两条, 均为单字节指令。\nMOVX用于累加器A与外部数据存储器进行传送。\n可以是MOVX A, @DPTR, MOVX A, @Ri, MOVX @DPTR, A, MOVX @Ri, A。\n当采用Ri作间接寻址时, 只能寻找片外256个单元的数据存储器, 此时8位地址和数据均由P0口传送。\n\n假设指令DJNZ R7, rel位于005FH, 如果在执行该指令前寄存器R7值为00H, 偏移量rel为02H, 则该指令执行后下一条要执行的指令所在的地址是0063H。\nDJNZ R7, rel位于005FH, 该指令长度为2字节 (书上写的3字节是错的), 所以在执行这条指令开始时PC值在原来的基础上 + 2 变为0061H。又因为rel为02H, 所以执行这条指令后, PC值变为0063H。\n\n分析下面子程序的功能, 假设8051单片机的震荡频率为6MHz。\n1\n2\n3\n4\n5\n6\n7DL: MOV R7, #0AH\nL0: MOV R6, #250\nL1: NOP\n    NOP\n    DJNZ R6, L1\n    DJNZ R7, L0\n    RET\nR7为10, R6为250, 因此两个NOP加上一个DJNZ一共循环了250次, 该250次的循环一共执行了10次。\nNOP为1周期指令, DJNZ为2周期指令, 两个NOP加一个DJNZ共4周期。\n6MHz下一个机器周期为 $12 \\div (6 \\times 10^6)= 2{\\mu}s$, 12MHz下一个机器周期为1微秒。\n故程序该子程序延时了$(4 \\times 250 \\times 10 \\times 12) \\div (6 \\times 10^6) = 20(ms)$。\n(实际上有10次MOV R6, #250和10次DJNZ R7, L0造成的30个机器周期的约0.6ms的误差)\n\n\n\n\n以下部分写于2020年11月25日\n\n汇编语言程序\n\n编写一个子程序, 将内部RAM 40H~4FH的内容复制到50H~5FH。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11COPY: MOV R0, #40H\n      MOV R1, #50H\n      MOV R2, #10H\n      ; 40H~4FH一共复制了16次\nLOOP:\n      MOV A, @R0\n      MOV @R1, A\n      INC R0\n      INC R1\n      DJNZ R2, LOOP\n      RET\n因为没有MOV @RX, @RX这条指令, 所以用A做数据的中转站。\n\n将任何无符号8位二进制数转换为BCD码的子程序, 入口参数为内部RAM单元20H, 出口参数为内部RAM单元30H和31H, 30H存放百位数, 31H存放十位数和个位数。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15CV:\nMOV R0, #20H\nMOV A, @R0\nMOV B, #100\nDIV AB; A除以100, 得到的百位数存在A中\nMOV 30H, A\nMOV A, B\n\nMOV B, #10\nDIV AB\n\nSWAP A\nADD A, B; 也可以用ORL\nMOV 31H, A\nRET\nDIV AB和MUL AB的A和B之间没有逗号。\n\n内部RAM 30H单元存放两位十进制数 (压缩BCD码), 编写将该十进制数转换为对应ASCII码的子程序, 转换结果存放到内部RAM 40H (十位数) 和41H (个位数) 单元。\n\nASCII码： 30H为0, 41H为A, 61H为a\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17CV:\nMOV A, 30H\nANL A, #0FH\nMOV DPTR, #DATA; 或者直接用ADD A, #30H即可\nMOVC A, @A+DPTR\nMOV 41H, A\n\nMOV A, 30H\nSWAP A\nANL A, #0FH\nMOVC A, @A+DPTR\nMOV 40H, A\n\nRET\n\nDATA:\nDB 30H, 31H, 32H, 33H, 34H, 35H, 36H, 37H, 38H, 39H\n\n8个8位数相加, 求平均值, 入口地址为30H~37H, 结果存到40H。\n把8位数相加存在溢出, 所以把相加结果以16进制存到R2、R3中, 再除以8( 右移3次), 即可求得不四舍五入的平均值。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14MOV R0, #30H\nMOV R1, #08H\nMOV R2, #00H\nMOV R3, #00H\n; 初始化\nLOOP:\nMOV A, @R0\nADD A, R3\nMOV R3, A\nJNC SKIP\nINC R2\nSKIP:\nINC R0\nDJNZ R1, LOOP   \n这样结果被保存到R2、R3中, 然后需要写一个循环右移3位的程序。\n1\n2\n3\n4\n5\n6\n7\n8MOV R4, #03H\nLOOP2:\nRRC R2\nRRC R3\nDJNZ R4, LOOP2\n\nMOV 40H, R3\n; 右移3次后R2的低4位为0\n这样R3中求得的是不带四舍五入的结果。\n如果需要带四舍五入的话第一种方法是判断最后一次右移时最低位是否为$1$， ($1 / 2 = 0.5$)。   \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12MOV R4, #03H\nLOOP2:\nCLR C\nRRC R2\nRRC R3\nDJNZ R4, LOOP2\n\nJNC SKIP2\nINC R3\nSKIP2:\nMOV 40H, R3\n; 右移3次后R2肯定为0\n这样是带四舍五入的结果。\n第二种方法，8个8位数相加求平均值，要求四舍五入的话，只需要在这8个数求和后再加4（0100B），之后右移3次。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11ADD A, #04H\nMOV R3, A\nJNC SKIP2\nINC R2\n\nSKIP2:\nMOV R4, #03H\nLOOP2:\nRRC R2\nRRC R3\nDJNZ R4, LOOP2\n结果保存在R3中。\n\n\n\n中断系统\n\n8051的外部中断有低电平触发和下降沿触发两种触发方式。外部中断1的中断向量地址是0013H。\n在响应中断时, 单片机自动生成一条长调用指令LCALL addr16, 其地址为中断入口地址。\n\n\n\n中断源\n入口地址\n\n\n\nINT0\n0003H\n\n\nT0\n000BH\n\n\nINT1\n0013H\n\n\nT1\n001BH\n\n\n串行口\n0023H\n\n\n通常在中断入口地址处放一条无条件转移指令*JMP。\n内部查询顺序同入口地址的顺序，由高到低。\n\n执行指令MOV IP, #0BH( #00001011B)后, 中断优先级最高者为PX0, 最低为PS。\nIP: 中断优先级寄存器, 其前3为无意义, 后5位( IP.4至IP.0)为：PS, PT1, PX1, PT0, PX0, 分别对应串行口、定时器T1、外部中断1、定时器0、外部中断0。\n\n\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nIP\n\n\n\nPS\nPT1\nPX1\nPT0\nPX0\n\n\n单片机复位以后, IP的内容为0, 各个中断源均为低优先级中断。\n在同时收到几个同一优先级的中断请求时, 中断响应取决于内部查询顺序, 其顺序由高到低为：INT0、T0、INT1、T1、串行口。\n当中断源均为同一优先级时, 当它们同时申请中断时CPU首先响应外部中断0\n\n8051的晶振频率为12MHz, 则最短的外部中断响应时间为3us, 最长的外部中断响应时间为12us。\n\n中断标记位于单片机寄存器的TCON和SCON中。\n\n\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nTCON\nTF1\nTR1\nTF0\nTR0\nIE1\nIT1\nIE0\nIT0\n\n\nSCON\n\n\n\n\n\n\nTI\nRI\n\n\nTCON中TF1和TF0为定时器/计数器中断标志位, TR1和TR0为定时/计数启动位, IE1和IE0为外部中断标志位, IT1和IT0为选择外部中断为边沿触发(1)还是电平触发(0)方式。\nSCON中的TI和RI( 是大写字母I不是数字1)分别为串行口中断发送中断请求标志位(发送成功后置1)和接受中断请求标志位( 接受成功后置1)。串口中断无法硬件清零, 只能软件清零。\n\n要使8051能够响应定时器T1的中断和串行口中断, 不响应其他中断, 则中断允许寄存器IE的内容为98H( 10011000B)。\n中断允许寄存器IE：\n\n\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nIE\nEA\n\n\nES\nET1\nEX1\nET0\nEX0\n\n\nEA为总控制位, 当EA为1时, CPU才可以响应中断请求。\nES为串行口中断允许位, ET1和ET0为定时器中断允许位, EX1和EX0为外部中断允许位。\n\n\n\n定时器和计数器\n\n使T0工作方式1的溢出周期最长的初值是0000H。\n定时器/计数器工作在方式0为13位计数器, 由TLX的低5位和THX的高8位组成13位计数器, 最大值为$2^{13}-1 = 8191$, 晶振频率12MHz下计时周期最长为8.192ms。工作在方式1时由均为8位的TLX和THX组成16位计数器, 最大值为65535, 晶振频率为12M下最长为65.536ms。\n当定时器/计数器工作在方式2时, 可以循环定时/计数。当计数溢出后, 自动将8位的THX装入8位的TLX中, 可省去重装初值的时间, 最大值为255, 晶振频率12M下计时周期最长为0.256ms。\n\nT1配置为方式3时, 停止计数, 方式3只适用于定时器0。\n定时器T0的方式3将其分为两个8位定时器, 其中TH0只能做定时器使用。\n\n设8051单片机的晶振频率为12MHz, 定时器作计数器使用时, 其计数输入信号的最高频率为500KHz。\n当定时器用作计数器时, 当检测到引脚上的负跳变时计数器的值增一。检测下降沿需要2个机器周期, 即24个震荡周期, 所以输入信号最高频率为 $12M \\div 24 = 500KHz$。\n\n用定时器方式2扩展一个下降沿触发的外部中断, 计数初值应为FFH。\n此处定时器2以计数器方式运行, 当检测到一个下降沿后, 计数器加一后溢出, 因此会执行定时器中断的中断子程序。\n\n\n\n\n2020年12月3日：\n前两天感冒, 休息了几天(打了两天的游戏)后继续。\n\n串行口\n\n串行口TXD为高电平, 表示这是数据位或停止位或空闲状态。\n串行口工作在方式1时, TXD用来发送数据、RXD用来接受数据。方式1的一帧数据为10位, 起始为为0, 停止位为1, 数据位和空闲状态均可能为0或1。\n\n串行口工作在方式3时, 发送的第9位数据要事先写入寄存器SCON的D3位(TB8), 接收的第9位数据被写入同一寄存器的D2位(RB8)。\n串行口控制寄存器SCON：\n\n\n\n\nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n\n\nSCON\nSM0\nSM1\nSM2\nREN\nTB8\nRB8\nTI\nRI\n\n\n其中SM0、SM1为串口的工作方式选择位, 方式0为同步移位寄存器方式, 方式1为8位异步收发, 方式2和方式3为9位异步收发。\n波特率：串行口每秒钟传送的比特位数，单位bits/s。\n方式0的波特率固定为 $f_{osc}/12$, 方式2的波特率为 $f_{osc}/64$ 或 $f_{osc}/32$ (由SMOD控制)。\n方式1的波特率和方式3的波特率可变, 公式为 $(2^{SMOD} / 32) \\times 定时器T1的溢出率$。\n即:\n$$ 波特率 = \\frac{(2^{SMOD} \\div 32) \\times f_{osc}}{12 \\times (256 - X)}$$\n$X$为定时器T1的初值。\n串口工作在方式1，波特率为2400，则每秒钟最大能发送/接收 $2400 \\div 8 = 300Byte$的数据。\n8051的UART工作在方式3，要求每秒钟能传送不少于900个字节的数据，则波特率应当大于 $900 \\times 8 = 7200bits/s$。\n\n比特率2400Kbits/s，PC机发送8个字节的数据存到单片机的30H-37H中，随后单片机发送2个确认字节55H和AAH给PC机，使用查询方式。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34ORG 0000H\nMAIN:\nMOV SCON, #50H\n; 串口使用方式1，且允许接收\nMOV PCON, #00H\n; 波特率不加倍\nMOV TMOD, #20H\n; 定时器1使用方式2\n\nMOV TL1, #0F3H\nMOV TH1, #0F3H\nSETB TR1\n\nLOOP:\nMOV R0, #30H\nMOV R1, #08H\n\nREC:\nJNB RI, $\nMOV @R0, SBUF\nCLR RI ; 软件清零RI\nINC R0\nDJNZ R1, REC\n\nMOV SBUF, #55H\nJNB TI, $\nCLR TI\n\nMOV SBUF, #0AAH\nJNB TI, $\nCLR TI\nAJMP LOOP\n\nEND\n单片机接收到数据后，RI被置1，代表SBUF中的数据有效，取走SBUF中的数据后需要软件清零RI（串口中断不会自动清零RI）。\n当单片机执行写SBUF操作时，串口发送开始，TI被自动置1，在发送完成后TI被自动清0.\n\n\n\n\n2020年12月7日：\n\nI/O口 &amp; 外部存储器拓展\n\n8051使用指令MOVX A, @R0读外部数据存储器时，不起作用的信号是WR。\n8051在读外部数据存储器时，P0和P2先输出外部数据的地址，单片机发出ALE信号（第电平有效）将P0口输出的地址锁存在74HC573里，之后单片机发出RD信号（低电平有效），读取外部数据存储器（RAM）的数据到总线再传送到P0口上。最后单片机从P0口读取数据保存到A中。\n如果是写外部数据存储器时，单片机将不发出RD信号而是WR信号，将A中的数据写入外部数据存储器中。\n\n存储器芯片6264需要13根地址线。\n62256的容量为 $256Kbit \\div 8 = 32KB = 2^{15}$, 需要15根地址线。\n6264的容量为 $64Kbit \\div 8 = 8KB = 2^{13}$，所以需要13根地址线。\n6116容量为 $16Kbit \\div 8 = 2KB = 2^{11}$, 需要11根地址线。\n计算方法是62$X$的 $容量=X \\div 8(K)$。\n\n使用16位地址模式时，8051的外部数据存储器寻址空间为64KB。\n\n基于8051的单片机系统能拓展的外部数据存储器容量无限制。\n有的书上说最大只能拓展64KB，实际是最大寻址空间为64KB，拓展的外部数据存储器容量无限制。\n\n8051的程序存储器可用来存放用户程序和数据。 例如使用DW或DB指令用来定义数据。\n所以应用程序也可以使用MOVC A, @A+DPTR访问程序存储器中的数据。\n\n\n\n除此之外LED数码管和外部存储器拓展、外部I/O设备拓展部分有很多需要看线路图才能做的题，因为线路图源自老师提供的PDF，而老师为PDF加了密码，意味着不允许外传，所以我就不放到博客上面了，除非我自己用Porteus画一个类似的\n\n\n\n\n\nTo be continued...\n\n"},{"title":"惠普光影精灵4在Arch Linux下使用Optimus Manager配置双显卡","url":"/posts/archlinux-pavilion-gaming-laptop/","content":"\n\n自从高中毕业至今这台笔记本用了将近两年, 已经记不清当初为什么买了这台笔记本, 刚买来电脑第一次装Arch Linux时遇到了一些坑, 不过大多数的问题Google折腾一会或随着后续的软件更新基本上就都解决了, 唯独配置双显卡这个问题在用了两年后才算是找到了比较满意的解决方法（大概是）, 尽管现在这电脑已经停产了, 就算有人买了这台电脑也不一定会拿他装Arch Linux, 不过我还是打算把这个问题的解决过程记录一下（本篇讲的方法应该是适用于大多数N卡+i卡的笔记本电脑的, 只是有些细节不一样）, 以备我后续重装系统时有个参考。\n\n\n\n \n\n\nconst ap0 = new APlayer ({\n    container: document.getElementById(\"aplayer0\"),\n    theme: \"#33363b\",\n    fixed: false,\n    listFolded: false,\n    listMaxHeight: false,\n    lrcType: false,\n    mini: false,\n    volume: 0.7,\n    order: \"list\",\n    loop: \"all\",\n    autoplay: false,\n    audio: [{\n        name: \"Kaleidoscope\",\n        artist: \"Vicetone / Grace Grundy\",\n        url: \"https://music.starry-s.me/music/560e_0558_060b_adc45c798222ffa86a4d1a0cb6ddf18f.m4a\",\n        cover: \"https://music.starry-s.me/music/cover/18671906464338403.jpg\",\n        lrc: \"\",\n        theme: \"#A26208\"\n    }]\n});\n  \n\n先描述一下踩坑经过\n\n本段略微有些废话, 可以跳过\n\n记得在刚买来这台笔记本（2018年夏）, Linux内核还没升到5.0的时候, 使用live CD装系统时会遇到lspci卡死, 关机的时候会卡死的问题, 查系统日记都是一堆ACPI的报错。当时网上查了一下大概是内核和驱动一些bug, 没找到解决办法（补充：是nouveau的问题, 内核参数添加modprobe.blacklist=nouveau禁用可以暂时解决问题）, Google到论坛的帖子说是在关机/重启发生卡死时直接长按电源关机就好了, 对电脑没有影响（找不到搜的回答了）\n装完系统后安装显卡驱动时想通过Bumblebee + bbswitch切换双显卡, 于是装了Gnome然后照着wiki配置完Bumblebee后重启电脑直接死机（补充：应该是bbswitch导致的ACPI锁死）。\n经过多次重装系统的折磨后, 发现只装Bumblebee不装bbswitch不systemctl enable bumblebeed.service时, 能正常开机, 然后之前遇到的两个问题也莫名其妙就好了, 即系统重启关机不会卡死, lspci也正常了（迷）\n之后, 在不装bbswitch的情况下, systemctl enable bumblebeed再用optirun和primusrun这种方式用独显运行程序都没有问题。\n当时以为电脑不装bumblebee的话就没法正常关机, 于是就一直用着bumblebee切换双显卡, 玩游戏性能比Windows下差一点（貌似是显卡驱动的锅？）, 别的都没啥问题。\n今年年初买了一块拓展屏想搞双显示器, 本来显示器应该插上HDMI直接就能用的, 但是因为这电脑的HDMI走的独显输出, Bumblebee不能直接用, wiki上教的创建个intel的虚拟输出啥的方法有试过但是没成功过（不知道是配置文件写错了还是啥问题）, 于是又Google了一下后disable并卸了Bumblebee改用NVIDIA Optimus 只使用独显的方式, 这样双显示器倒是能用了, 但是如果笔记本只用电池没连着拓展屏的时候还跑着独显这也太费电了。\n所以最后找到了能切换显卡的Optimus Manager。\n安装过程\n照着Wiki和Optimus Manager的README。首先安装好显卡驱动相关的软件, 如果有Bumblebee的话使用systemctl disable bumblebeed停用。\n首先清除（记得备份）/etc/X11/xorg.conf.d/下的配置文件, 并删掉（记得备份）/etc/X11/xorg.conf（如果有的话）, 因为Optimus Manager会自动生成配置文件存放到/etc/X11/xorg.conf.d/里面, 所以建议安装前把显示配置相关的文件都清除掉。\n使用Arch Linux CN源或者通过AUR Helper安装optimus-manager。\n1\n2\n3\n4# Arch Linux CN\n$ sudo pacman -S optimus-manager\n# AUR\n$ yay -S optimus-manager\n因为我用的Gnome, 参照README中说的卸载掉gdm并安装gdm-primeAUR。（国内下载源代码的速度极慢建议挂梯子, 或者挂梯子克隆GDM的代码到~/.cache/yay/gdm-prime/gdm下。）\n修改/etc/gdm/custom.conf, 移除WaylandEnable=false一行前面的#禁用Wayland而使用X。\n修改配置文件\n1$ sudo cp /usr/share/optimus-manager.conf /etc/optimus-manager/optimus-manager.conf\n不要编辑/usr/share/下的文件, 编辑/etc/optimus-manager/optimus-manager.conf, 将切换方式设为switching=none, 不推荐使用bbswitch（见后续第一条）, 设置pci_power_control=yes让PCI Power Management切换显卡。\n之后根据需求来修改开机自动选择显卡：\n1\n2\n3startup_mode=auto\nstartup_auto_battery_mode=intel\nstartup_auto_extpower_mode=nvidia\n这里我设置的是用电池时使用集成显卡, 用电源时使用独显。\n最后贴一下全部的配置文件, 除了上述的几处修改以外其他均为默认值, 仅供参考。\n\n# Leave blank for the default (the above command will not be run).\nDPI=96\n\n# If you're running an updated version of xorg-server (let's say to get PRIME Render offload enabled),\n# the nvidia driver may not load because of an ABI version mismatch. Setting this flag to &quot;yes&quot;\n# will allow the loading of the nvidia driver.\nignore_abi=no\n\n# Set to yes if you want to use optimus-manager with external Nvidia GPUs (experimental)\nallow_external_gpus=no\n\n# Comma-separated list of Nvidia-specific options to apply.\n# Available options :\n# - overclocking : enable CoolBits in the Xorg configuration, which unlocks clocking options\n#   in the Nvidia control panel. Note: does not work in hybrid mode.\n# - triple_buffer : enable triple buffering.\noptions=overclocking\n\" data-info=\"language-conf\" data-lang=\"conf\" class=\"code-block highlight hljs\">1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109[optimus]\n\n# This parameter defines the method used to power switch the Nvidia card. See the documentation\n# for a complete description of what each value does. Possible values :\n#\n# - nouveau : load the nouveau module on the Nvidia card.\n# - bbswitch : power off the card using the bbswitch module (requires the bbswitch dependency).\n# - acpi_call : try various ACPI method calls to power the card on and off (requires the acpi_call dependency)\n# - custom: use custom scripts at /etc/optimus-manager/nvidia-enable.sh and /etc/optimus-manager/nvidia-disable.sh\n# - none : do not use an external module for power management. For some laptop models it's preferable to\n#          use this option in combination with pci_power_control (see below).\nswitching=none\n\n# Enable PCI power management in Intel mode.\n# This option is incompatible with acpi_call and bbswitch, so it will be ignored in those cases.\npci_power_control=yes\n\n# Remove the Nvidia card from the PCI bus.\n# May prevent crashes caused by power switching.\n# Ignored if switching=nouveau or switching=bbswitch.\npci_remove=yes\n\n# Reset the Nvidia card at the PCI level before reloading the nvidia module.\n# Ensures the card is in a fresh state before reloading the nvidia module.\n# May fix some switching issues. Possible values :\n#\n# - no : does not perform any reset\n# - function_level : perform a light \"function-level\" reset\n# - hot_reset : perform a \"hot reset\" of the PCI bridge. ATTENTION : this method messes with the hardware\n#         directly, please read the online documentation of optimus-manager before using it.\n#         Also, it will perform a PCI remove even if pci_remove=no.\n#\npci_reset=no\n\n# Automatically log out the current desktop session when switching GPUs.\n# This feature is currently supported for the following DE/WM :\n# KDE Plasma, GNOME, XFCE, LXDE, Deepin, i3, Openbox, AwesomeWM, bspwm\n# If this option is disabled or you use a different desktop environment,\n# GPU switching only becomes effective at the next graphical session login.\nauto_logout=yes\n\n# GPU mode to use at computer startup. Possible values: nvidia, intel, hybrid, auto\n# \"auto\" is a special mode that auto-detects if the computer is running on battery\n# and selects a proper GPU mode. See the other options below.\nstartup_mode=auto\n# GPU mode to select when startup_mode=auto and the computer is running on battery.\n# Possible values: nvidia, intel, hybrid\nstartup_auto_battery_mode=intel\n# GPU mode to select when startup_mode=auto and the computer is running on external power.\n# Possible values: nvidia, intel, hybrid\nstartup_auto_extpower_mode=nvidia\n\n\n[intel]\n\n# Driver to use for the Intel GPU. Possible values : modesetting, intel\n# To use the intel driver, you need to install the package \"xf86-video-intel\".\ndriver=modesetting\n\n# Acceleration method (corresponds to AccelMethod in the Xorg configuration).\n# Only applies to the intel driver.\n# Possible values : sna, xna, uxa\n# Leave blank for the default (no option specified)\naccel=\n\n# Enable TearFree option in the Xorg configuration.\n# Only applies to the intel driver.\n# Possible values : yes, no\n# Leave blank for the default (no option specified)\ntearfree=\n\n# DRI version. Possible values : 2, 3\nDRI=3\n\n# Whether or not to enable modesetting for the nouveau driver.\n# Does not affect modesetting for the Intel GPU driver !\n# This option only matters if you use nouveau as the switching backend.\nmodeset=yes\n\n[nvidia]\n\n# Whether or not to enable modesetting. Required for PRIME Synchronization (which prevents tearing).\nmodeset=yes\n\n# Whether or not to enable the NVreg_UsePageAttributeTable option in the Nvidia driver.\n# Recommended, can cause poor CPU performance otherwise.\nPAT=yes\n\n# DPI value. This will be set using the Xsetup script passed to your login manager.\n# It will run the command\n# xrandr --dpi &lt;DPI&gt;\n# Leave blank for the default (the above command will not be run).\nDPI=96\n\n# If you're running an updated version of xorg-server (let's say to get PRIME Render offload enabled),\n# the nvidia driver may not load because of an ABI version mismatch. Setting this flag to \"yes\"\n# will allow the loading of the nvidia driver.\nignore_abi=no\n\n# Set to yes if you want to use optimus-manager with external Nvidia GPUs (experimental)\nallow_external_gpus=no\n\n# Comma-separated list of Nvidia-specific options to apply.\n# Available options :\n# - overclocking : enable CoolBits in the Xorg configuration, which unlocks clocking options\n#   in the Nvidia control panel. Note: does not work in hybrid mode.\n# - triple_buffer : enable triple buffering.\noptions=overclocking\n\n食用方法\noptimus-manager --switch nvidia切换到独显（nvidia）\noptimus-manager --switch intel切换到集显（intel）\n安装mesa-demos后, 使用glxinfo | grep \"OpenGL renderer\"查看当前正使用的显卡\n其他用法参见Usage。\n注意：\n\n切换显卡的过程中会自动注销登录, 所以记得保存并关掉电脑正在运行的程序。\n\n你可以在配置文件中修改auto_logout=false禁止自动注销以手动注销切换显卡。\n\n\nOthers\n\n之所以不推荐使用bbswitch是因为容易遇到ACPI锁死的问题, 参考Wiki, 需要添加内核参数acpi_osi=! acpi_osi=\"Windows 2009\"或acpi_osi=\"!Windows 2015\"启动, 如果你遇到了锁死可以通过开机时在启动加载器界面编辑添加内核参数来正常进入系统, 如果你用的是efistub或者没办法编辑内核参数的话就只能用live CD救你的电脑了。\n\n如果用不了lspci, 电脑没法正常关机的话, 是nouveau的问题, 可添加内核参数modprobe.blacklist=nouveau禁用。\n\n因为前几天改配置文件时又踩了一遍锁死的坑, 于是拿着相机内存卡（我U盘放学校寝室里拿不出来了）做了最新的(2020.07.01)live CD救砖时, 惊喜的发现在live环境下lspci和关机都不会卡死了, 貌似是新版内核驱动修复了nouveau的问题 应该是我在几个月前升级了电脑的Bios解决的这个问题, 因为我又新下了一个旧的live CD, 关机和lspci也都正常了（算了不管到底是怎么回事了, 能用就行\n\n在切换显卡自动注销后, gdm界面不会自动加载出来而是一直黑屏, 这时需要手动切换到tty2再切回tty1才能加载出来, 貌似是gdm-prime的问题。\n\n(本条与配置显卡无关) 因为电脑用的intel网卡, 如果遇到蓝牙耳机无法连接的情况, 安装pulseaudio和pulseaudio-modues-bt等耳机需要的蓝牙组件, 照着Wiki上的禁用Bluetooth coexistence解决此问题。\n\n\n\n\n    \n"},{"title":"小米路由器3G折腾之刷OpenWrt记录","url":"/posts/Xiaomi_Miwifi_3G/","content":"\n\n本篇恢复自旧博客, 由于创作时间过于久远, 作者已无法保证其准确性, 内容仅供参考。\n\n生命不息, 折腾不止...\n\n\n\n \n\n\nconst ap0 = new APlayer ({\n    container: document.getElementById(\"aplayer0\"),\n    theme: \"#33363b\",\n    fixed: false,\n    listFolded: false,\n    listMaxHeight: false,\n    lrcType: false,\n    mini: false,\n    volume: 0.7,\n    order: \"list\",\n    loop: \"all\",\n    autoplay: false,\n    audio: [{\n        name: \"Mallow Flower\",\n        artist: \"Otokaze\",\n        url: \"https://music.starry-s.me/music/969d_ef88_965d_f8693c4f0a65db94a9cc0ebb9be2bd06.mp3\",\n        cover: \"https://music.starry-s.me/music/cover/781752767371058.jpg\",\n        lrc: \"\",\n        theme: \"#EFCE82\"\n    }]\n});\n  \n\n准备工作\n你至少需要以下工具：\n\n路由器本体\n网线\n一个已格式化为FAT/FAT32格式的U盘, 用来刷开发者固件和ssh激活工具\n一根怼Reset钮的针\nWindows用户需要一个SSH软件（例如：putty）\n小米路由器客户端, 用来绑定你的小米账号\n\nSSH到路由器\n\n路由器重启后指示灯会变为蓝色, 若变为红色则为刷机失败。\n\n安装开发者固件并开启SSH权限：\n\n在MiWiFi下载页面下载所需要的路由器开发者固件（ROM -&gt; ROM for R3G开发版）,命名为miwifi.bin。\n\n路由器断电, 将下载好的开发者固件放入U盘插入路由器USB接口, 捅住reset扭接上电源后待指示灯为黄色闪烁时松开, 数分钟后路由器会自动重启, 此过程不要乱动路由器。\n\n小米路由器客户端登陆小米账号绑定路由器设备, 此过程需要路由器联网。\n\nMiWiFi开放平台登陆小米账号下载ssh激活工具命名为miwifi_ssh.bin, 记下root密码。\n\n操作方式同第二步骤, 刷入ssh激活工具。\n\n\nSSH到路由器:\n\nWindows系统用putty, ip为191.168.31.1, 用户名：root, 密码为下载激活ssh工具时记下的密码。\n\nUnix/Linux系统终端执行：ssh root@191.168.31.1\n\n\n刷入Bootloader（推荐/可选）\n\n该步骤可选是因为Breed不支持直接刷入Openwrt固件, 可参考这篇帖子, 不过为了防止变砖, 还是推荐刷Breed。\n\nBreed原作者为hackpascal, 此处为下载地址, 文件名为breed-mt7621-xiaomi-r3g.bin\n第一种方法是ssh到路由器后通过wget下载breed文件再刷入（需要确保路由器联网）, 下载地址为https所以需要加上--no-check-certificate参数。\n1\n2\n3cd /tmp\nwget --no-check-certificate https://breed.hackpascal.net/breed-mt7621-xiaomi-r3g.bin -O breed.bin\nmtd -r write breed.bin Bootloader\n另一种方法是将breed通过U盘拷贝到路由器再刷入。\n1\n2\n3mkdir /tmp/sdcard\nmount /dev/sda1 /tmp/sdcard\nmtd -r write /tmp/sdcard/breed.bin Bootloader\n路由器刷写完毕后会自动重启, 在写入Breed的过程中不要动路由器。\n刷机\n下载所需固件：\n\ntuna镜像站的OpenWrt下载地址：https://mirrors.tuna.tsinghua.edu.cn/lede/releases/\n\n官方下载地址: https://downloads.openwrt.org/releases/\n\n\n使用Breed的刷机方法\n按照hackpascal的说法是：\n\n如果kernel0存在kernel1不存在, 那么启动kernel0\n如果kernel1存在kernel0不存在, 那么启动kernel1\n如果kernel0和kernel1都存在, 那么检查环境变量 xiaomi.r3g.bootfw 的值, 如果存在且值为 2, 那么启动kernel1, 否则启动kernel0\n\n简单来说就是：路由器有两个内核, 需要在Breed里设置环境变量让路由器启动kernel1。\n\n刷入Openwrt固件到Kernel1\n1\n2mtd write openwrt-18.06.2-ramips-mt7621-mir3g-squashfs-kernel1.bin kernel1\nmtd write openwrt-18.06.2-ramips-mt7621-mir3g-squashfs-rootfs0.bin rootfs0\n\n路由器断电, 捅住reset按钮后通电, 待指示灯变为蓝色闪烁后用网线连接路由器到电脑, 浏览器打开网址192.168.1.1, 进入Breed界面。\n\n在环境变量编辑里添加xiaomi.r3g.bootfw字段, 值为2,保存后重启即可进入Openwrt。\n\n\n没有刷入Breed的刷机方法\n\nOpenWrt官网提供的教程是在没有刷入Breed的情况下刷入OpenWrt固件的。\n\nssh到路由器, 导入固件后刷机。\n1\n2\n3\n4\n5\n6mtd write openwrt-18.06.2-ramips-mt7621-mir3g-squashfs-kernel1.bin kernel1\nmtd write openwrt-18.06.2-ramips-mt7621-mir3g-squashfs-rootfs0.bin rootfs0\nnvram set flag_try_sys1_failed=1\nnvram commit\n\nreboot\n\nOthers\n\n如果刷了Breed + Pandavan/PandoraBox后想换回OpenWrt的话, 首先在Breed中刷回小米路由器开发版的官方固件, 然后SSH到路由器按照上述的使用Breed的刷机方法再刷机。\n\nUSB3.0会对路由器的2.4G频段信号造成干扰。\n\nOpenWrt默认语言为英文, 可安装luci-i18n-base-zh-cn,luci-i18n-base-zh-tw安装简体/繁体中文。\n\nOpenWrt-dist可拓展更多功能。\n\n为优化软件包安装速度, 可将opkg源改为国内：\nLuCI -&gt; System -&gt; Software -&gt; Configuration 中将 Distribution feeds 的http://downloads.openwrt.org替换为http://mirrors.tuna.tsinghua.edu.cn/lede。\n\nOpenWrt可安装软件包libustream-openssl libustream-mbedtls解决wget无法访问https服务器问题。\n然后建议把opkg源能改为https的都改为https。\n\n\n"}]}